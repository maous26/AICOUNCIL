import { NextResponse } from 'next/server';
import { AgentId, Message } from '@/types';
import { createOrchestrator } from '@/lib/orchestration/engine';
import { OrchestrationStrategy } from '@/lib/orchestration/types';
import { executeAgent } from '@/lib/agents/clients';
import { AGENT_PROMPTS } from '@/lib/orchestration/prompts';

export async function POST(request: Request) {
    try {
        const {
            message,
            history,
            strategy = 'sequential',
            returnFullDebate = false
        } = await request.json();

        if (!message) {
            return NextResponse.json({ error: 'Message is required' }, { status: 400 });
        }

        // Validate orchestration strategy
        const validStrategies: OrchestrationStrategy[] = ['parallel', 'sequential', 'debate', 'voting', 'consensus'];
        const orchestrationStrategy: OrchestrationStrategy = validStrategies.includes(strategy)
            ? strategy
            : 'sequential';

        // Create orchestrator with selected strategy
        const orchestrator = createOrchestrator(orchestrationStrategy);

        // Convert history to Message format
        const conversationHistory: Message[] = history || [];

        // Execute orchestration
        const result = await orchestrator.orchestrate(
            message,
            conversationHistory,
            async (agentId: AgentId, prompt: string, systemPrompt: string) => {
                return await executeAgent(agentId, prompt, systemPrompt);
            }
        );

        // Prepare response
        if (returnFullDebate) {
            // Return complete debate information
            return NextResponse.json({
                strategy: result.strategy,
                rounds: result.rounds.map(round => ({
                    roundNumber: round.roundNumber,
                    responses: round.responses.map(r => ({
                        agentId: r.agentId,
                        agentName: AGENT_PROMPTS[r.agentId].role,
                        content: r.content,
                        timestamp: r.timestamp
                    })),
                    critiques: round.critiques?.map(c => ({
                        from: c.fromAgent,
                        to: c.toAgent,
                        critique: c.critique
                    }))
                })),
                consensus: result.finalConsensus,
                metadata: result.metadata
            });
        } else {
            // Return only the consensus (backward compatible)
            return NextResponse.json({
                content: result.finalConsensus,
                agentId: 'gpt', // Consensus is generated by GPT
                metadata: {
                    strategy: result.strategy,
                    rounds: result.rounds.length,
                    duration: result.metadata.duration
                }
            });
        }

    } catch (error: any) {
        console.error('Error in chat API:', error);
        return NextResponse.json({
            error: error.message || 'Internal Server Error',
            details: process.env.NODE_ENV === 'development' ? error.stack : undefined
        }, { status: 500 });
    }
}
